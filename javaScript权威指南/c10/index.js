// *********************** 正则表达式的模式匹配 ***********************
//正则表达式(regulat expression) 是一个描述字符模式的对象.JS找那个RegExp类表示正则表达式.String和RegExp都定义了方法.
//js正则表达语法是Perl5的正则表达式语法的大型子集.
//本章首先介绍用以描述的"文本模式"的正则表达式语法
//随后讲解使用String和RegExp方法

//10.1 正则表达式的定义
// 1.使用RegExp()构造函数来创建RegExp对象. 2.直接量创建.包含在一对斜杠之间.
var pattern = /s$/
//运行这段代码会穿件一个新的RegExp对象,并将它赋予给pattern
//也可以使用构造函数定义
var pattern = new RegExp('s$')

//10.1.1 直接量字符
// \o   null字符(\u0000)
// \t   制表符(\u0009)
// \n   换行符(\u000A)
// \v   垂直制表符(\u000B)
// \f   换页符(\u000C)
// \r   回车符(\u000D)
//在正则有许多标点符号具有特殊含义,他们是
// ^$.*+?=!:|\/()[]{}

//10.1.2 字符类
// 将直接量字符单独放进方括号[]就组成字符类(character class).
//一个字符类可以匹配它包含的任意字符 /[abc]/可以匹配'a','b','c'任意一个.
//另外可以通过"^"符号来定义否定字符类.他匹配所有不包括在方括号内的字符,定义一个否定字符类的时候,将一个"^"符号作为左方括号的第一个字符.
///[a-z]//[a-z0-9A-Z]/
// \s 空白符+制表符+其他unicode空白符
// \S 非Unicode空白符
// [...]   方括号内的任意字符
// [^...]  不在方括号内的任意字符
// .  除换行符和其他Unicode行终止符之外的任意字符
// \w 任何ASCII字符组成的单词,等价于[a-z0-9A-Z]
// \W 任何非ASCII字符组成的单词,等价于[^a-z0-9A-Z]
// \d 任何ASCII数字 等价于[0-9]
// \D 任何非ASCII数字 等价于[^0-9]

//10.1.3 重复
// 用刚学过的语法,可以把两位数描述成/\d\d/,四位数/\d\d\d\d/
// {n,m} 至少n 不超过m
// {n,} 至少n
// {n}  n次
// ?    0或者1 {0,1}
// +    1或多次 {1,}
// *    0或多 {0,}
//非贪婪的匹配 ?  尽量少的进行匹配

//10.1.4 选择,分组和引用
// 正则表达式的语法还包括制定选择项,子表达式分组,和引用前一子表达式的特殊字符.
//选择
// 字符"|"用于分隔供选择的字符 例如 /ab|cd|ef/   可以匹配"ab"或者 "cd" 或者"ef"  ,   /\d{3}|[a-z]{4}/ 匹配三个数组或者四个小写字母
//注意选择项的尝试匹配次序是从左到右的,直到发现了匹配项.如果左边的选择项成功了就忽略邮编的匹配项.
//分组
//正则中圆括号有多种作用. 一个作用是吧 单独的项组合成子表达式,以便可以想出一个一个独立单元那样使用 "|" "*" "+" 或者 "?" 等来对单元内的项进行处理
// /java(script)?/ 可以匹配"java" 也可匹配 "javascript",/(ab|cd)+|ef/  可以匹配 "ef" "ab" "cd"
// 另一个作用是在完整模式的定义子模式.当一个表达式成功与目标字符串想匹配时,可以从目标串中抽出与圆括号中子模式想匹配的部分.例如/[a-z]+(\d+)/  就可以从检索的匹配中抽取数字了.
// 还有一个用途是允许在同一个正则表达式的后部引用前面的子表达式.通过 "\"+表示位置的数字引用.
//例如 /([Jj]ava([Ss]cript)?\sis\s(fun\w*))/ 中可以\2===第二个带括号的子表达式=([Ss]cript)匹配的文本
//对于正则表达式中前一个子表达式的引用并不是指对子表达式模式的引用,而是指与那个模式相匹配的文本引用.这样引用可以用于实施一条约束,即一个字符串哥哥单独部分包含的是完全相同的字符.
//例如 下面的正则表达匹配违约单引号或者双引号之前的0个或者多个字符.但是他并不要求作者和有责引号匹配(即加入的两个引号都是单引号或者双引号)
//  /['"][^'"]['"]/
//如果要匹配左侧和右侧的引号,可以是通如下引用
// /(['"])[^'"]\1/
//在这里中,中间部分必须跟两边的引号不一致
// /(['"])[^\1]\1/
//同样在正则表达中不用穿件戴数字编码的引用,也可以对子表达式进行分组.他不是以 "(" 和 ")" 进行分组,以(?:和 )进行分组
///([Jj]ava(?:[Ss]cript)?\sis\s(fun\w*))/ 此时\2===第二个===(fun\w*)匹配的文本

//10.1.5 指定匹配位置
//正如前面介绍的,正则表达式中多个元素才能匹配字符串的一个元素.
//还有一个正则表达式的元素匹配的是字符之间的位置,而不是实际的字符.
//例如 \b匹配一个单词的边界,即位于\w(ASCII单词)字符和\W(非ASCII单词)之前的标记,或位于一个ASCII单词的开始或者结尾之间的边界.
//像这种不匹配某个可见的字符,他们制定匹配发生的合法位置,又是我们称这些元素为正则表达式的锚,因为他们将模式定位在搜索字符串的特定位置.
//最常见的锚元素是^,他用来匹配字符串的开始,锚元素$用来匹配字符串的借宿.
//任意表达式都可以做锚点条件,如果在符号(?=和)之间放入一个表达式,他就是一个先行断言,用以说明圆括号内的表达式必须正确匹配,丹并不是真正意义上的匹配.
//例如 要匹配一个常用摄者语言的名字,但是只在汽油有冒号的时候才匹配.
// /([Jj]ava(?:[Ss]cript)?(?=\:))/   可以匹配javascript:The中的javascript 但是不能匹配 javascript in a 中的 javascript
// 带有(?! 和)的断言是负向先行断言,用以指定接下的字符都不必匹配.
//例如 /Java(?!Script)([A-Z]\w*)/  可以匹配java后面跟随一个大写字母和任意多个ASCII单词,但是java后面不能跟随Script,他可以匹配 javaBbbb  javaAaaaa 但是不能匹配   javaaaa和javabbb和javaScript;

//10.1.6 修饰符
//位置  出现在第二条斜线之后
//js支持三个修饰符
//修饰符 i 用以说明模式匹配不区分大小写
//修饰符 g 用以说明模式匹配应该是群居的,也就是说,应该找出被检索字符串中所有的匹配.
//修饰符 m 用以在多行模式中执行匹配,在这种模式下,如果带检索的字符串中包含多行,name^$除了匹配整个字符串的开始和结尾外还能匹配每行的开始和结尾.

//10.2 用于模式匹配的String放啊
//string支持四种使用正则表达式的方法.
//search()  他的参数是一个正则表达式,返回第一个与之匹配的子串的其实位置,如果找不到返回-1
// console.log('JavaScript'.search(/script/i)) // 返回值为4
//如果search参数不是正则表达式.会首先通过RegExp转换成正则表达式.
//search()方法不支持全局搜索
//replace() 方法用于执行检索与替换操作,第一个参数是一个正则表达式,第二个参数要进行替换的字符串.
//如果第一个参数不是正则,则直接搜索这个字符串
// "javascript".replace(/javascrpt/gi,"JavaScript")
// 回忆一下,上面使用()进行分组的时候,可以使用\1获取对应引用
//如果在replace()中替换字符出现了$加数字,那么将用与指定子表达式匹配的文本来替换这两个字符.
//用它将一个字符串中的英文引号替换成中文半角引号
//引号中间内容区域不存包引号
// var text = '我"是中间的"内"容"'
// var quote = /"([^"]*)"/g
// //用中文板件引号替换英文英豪,同事要保证内容没有被修改
// var t1 = text.replace(quote, ' ,$1, ') // $1 ===\1 ==== 匹配的()中的内容===如上的两个引号见的内容
// console.log(t1)
// //值得注意的是,replace()的第二参数可以是函数,该函数能够动态的计算替换字符串
// var t2 = text.replace(quote, function($1) {
//   console.log($1)
//   return '我是动态返回的结果'
// })
// console.log(t2)

//match()方法 他唯一一个参数就是一个正则表达式(或者通过RegExp()构造函数将其转为正则表达式),返回的是一个由匹配结果组成的数组.
//如果设置的修饰符g,则返回的数组包含字符串中所有的匹配结果.
// var text = '1 plus 2 equals 3'
// var r1 = text.match(/\d+/)
// var r2 = text.match(/\d+/g)
// console.log(r1)
// console.log(r2)
// //如果没有设置修饰符g,返回数组第一个元素就是匹配的字符串,鱼虾元素则是正则表达式中用圆括号()括起来的子表达式..
// //因此 如果match返回一个数字a,a[0]是完整的匹配,a[1]存放的第一个圆括号的匹配内容,a[n]是第n个匹配内容.
// var url = /(\w+):\/\/([\w.]+)\/(\S*)/
// var urlText = 'Visit my blog at http://www/example.com/~david'
// var result = urlText.match(url)
// console.log(result)
//值得注意是,给match传入的是一个非全局匹配的正则表达式.

//split() 这个方法用以将调用他的字符串分割成一个子串组成的数组,使用的分隔符是参数.
//允许两边刘任意多的空白符
//例如 "1,1,1,1,12,,3,34,4".split(",") => ["1","1","1","1","12" ...]

//10.3  RegExp 对象
//除了构造函数之外,还支持三个方法和一些属性
//构造函数接收两个参数,第二个参数是可选的
//需要注意的是 传入一个字符串表述的正则表达式的时候需要将\替换成\\
// var ztpcode = new RegExp('\\d{5}', 'g')  //全局匹配字符串中的5个数字

//10.3.1 RegExp的属性
//每个对象都包含五个属性
//属性 source是一个只读的字符串,包含正则表达式的文本
//属性 global是一个制度的布尔值,说明是否带有修饰符g
//属性ignoreCase也是一个只读的布尔值,用以说明正则表达式是否带有修饰符i
//属性multiline 也是只读的布尔值,用以说明是否带有修饰符m
//最后一个lastIndex,它是一个可读写的证书,如果带有g修饰符,这个属性储存在整个字符串中下一次检索开始的位置,这个属性会被exec()和test()使用到.

//10.3.2 RegExp的方法
//对象定义了两个用于执行模式匹配操作的方法.
//最主要的执行模式匹配的方法 exec() ,和string的match()相似.只是RegExp的参数是一个字符串,而string是一个RegExp对象.
//exec对象一个定福执行一个正则表达式,简言之,就是在一个字符串中执行匹配检索,如果没有找到任何匹配,就返回null.如果找一个匹配,就返回一个数组.就像match方法为费全局匹配返回的数组一样
//这个数组 第一恶元素是与正则表达式相匹配的字符串,余下元素是与圆括号内的子表达式相匹配的子串.
//属性index包含了发生匹配的字符位置,input引用的是正在检索的字符串
//和match不用的是exec不管是否具有全局修饰符,返回架构都是一样的.
//当带有g修饰符时候,exec将吧lastIndex设置为紧挨着匹配子串的字符位置,当同一个正则表达式 第二次调用exec的时候,他讲从lastIndex开始,当一个exec没有发现任何匹配结构,他将lastIndex重置为0
//利用这种特殊行为,我们可以在正则表达式匹配字符串的过程中重复调用exec
//例如
// var pattern = /Java/g
// var text = 'JavaScript is more fun than Java!'
// var result

// while ((result = pattern.exec(text)) != null) {
//   console.log(
//     "Matched'" +
//       result[0] +
//       "'at position " +
//       result.index +
//       ';next search begins at ' +
//       pattern.lastIndex
//   )
// }
// var result1 = pattern.exec(text)
// console.log(
//   "Matched'" +
//     result1[0] +
//     "'at position " +
//     result1.index +
//     ';next search begins at ' +
//     pattern.lastIndex
// )
// var result2 = pattern.exec(text)
// console.log(
//   "Matched'" +
//     result2[0] +
//     "'at position " +
//     result2.index +
//     ';next search begins at ' +
//     pattern.lastIndex
// )

//test()调用和exec等价,当exec范结果是null时候,test返回true,由于这种等价性,当一个群居正则表达式调用test()的时候,因为他从lastindex指定的位置开始检索某个字符串,如果啊找了一个额匹配结构,他就是立即设置lastindex魏当前匹配子串的几所位置,这样一来,就可以用test便利字符串,就像通exec一样.
